<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!--groupId第一段为域,第二段为公司名称-->
    <groupId>org.wonderming</groupId>
    <!--artifactId为项目名称-->
    <artifactId>YouQu</artifactId>
    <packaging>pom</packaging>
    <!--快照版本即为不稳定版本-->
    <version>1.0-SNAPSHOT</version>


    <properties>
        <spring.version>4.3.13.RELEASE</spring.version>
        <spring.security.version>4.2.4.RELEASE</spring.security.version>
        <spring.data.redis>1.8.14.RELEASE</spring.data.redis>
        <mybatis.version>3.4.5</mybatis.version>
        <mybatis.spring.version>1.3.1</mybatis.spring.version>
        <activemq.version>5.15.6</activemq.version>
        <dubbo.version>2.5.6</dubbo.version>
        <zookeeper.version>3.4.11</zookeeper.version>
        <zkclient.version>0.1</zkclient.version>
        <jedis.version>2.9.0</jedis.version>
        <ehcache.version>2.10.5</ehcache.version>
        <cache.api.version>1.0.0</cache.api.version>
        <org.slf4j.version>1.7.25</org.slf4j.version>
        <logback.classic.version>1.2.3</logback.classic.version>
        <servlet.api.version>3.1.0</servlet.api.version>
        <jsp-api.version>2.0</jsp-api.version>
        <joda.time.version>2.9.9</joda.time.version>
        <junit.version>4.12</junit.version>
        <jackson.version>2.9.6</jackson.version>
        <mysql.version>5.1.32</mysql.version>
        <druid.version>1.1.6</druid.version>
        <httpclient.version>4.5.5</httpclient.version>
        <commons.lang3.version>3.7</commons.lang3.version>
        <commons.io.version>1.3.2</commons.io.version>
        <commons.beanutils>1.9.3</commons.beanutils>
        <commons.pool2.version>2.6.0</commons.pool2.version>
    </properties>

    <dependencies>
        <!--Spring的IOC容器1.标识一个应用环境 2.利用BeanFactory创建Bean对象 3.保存对象关系表 4.能够捕获各种事件
            ApplicationContext的子类WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext
            去除<exclusions>自带的日志门面commons-logging
        -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>${spring.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>commons-logging</groupId>
                    <artifactId>commons-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--Spring的核心组件,定义资源的访问方式-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>${spring.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>commons-logging</groupId>
                    <artifactId>commons-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--Spring定义Bean,Bean的创建以及对Bean的解析-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-beans</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <!--Spring的单元测试-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <!--Spring提供对AspectJ的支持,面向切面的框架是SpringAOP的实现
            增强处理：
            @Before: 前置通知, 在方法执行之前执行
            @After: 后置通知, 在方法执行之后执行
            @AfterRunning: 返回通知, 在方法返回结果之后执行
            @AfterThrowing: 异常通知, 在方法抛出异常之后
            @Around: 环绕通知, 围绕着方法执行
        -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <!--Spring的面向切面编程
            Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理
            默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了
            当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB
            强制使用CGLIB生成代理，那就是<aop:config>里面有一个"proxy-target-class"属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用
        -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <!--Spring context的扩展支持，用于MVC方面。-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context-support</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <!--Spring 对jdbc的封装-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <!--Spring的消息队列-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jms</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <!--Spring事务管理
        DataSourceTransactionManager：适用于使用JDBC和iBatis进行数据持久化操作的情况 HibernateTransactionManager：适用于使用Hibernate进行数据持久化操作的情况 JpaTransactionManager：适用于使用JPA进行数据持久化操作的情况
        TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。
        TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。
        TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。
        TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

        TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
        TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
        TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
        TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
        TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
        TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
        TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

        -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
            <version>${spring.version}</version>
        </dependency>
    </dependencies>

</project>